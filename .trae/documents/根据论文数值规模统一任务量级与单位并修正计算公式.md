## 目标
- 参考 BARGAIN-MATCH 论文的数量级，将任务的输入数据、计算需求、截止时延统一到合理的量级与单位。
- 修正传输速率与计算处理公式，使单位自洽：R 为 bit/s；计算量为 cycles；时延为秒。

## 统一的单位与数量级
- 输入数据 D_i（上行）：单位 bit，量级 2–20 MB → 16–160 Mb（按车辆视频/图像卸载场景）。
- 计算需求 C_i：单位 cycles，量级 5e8–5e10 cycles（轻量到中等视觉/SLAM子任务）。
- 截止时延 τ_i：单位秒，量级 0.1–2.0 s。
- 服务器频率 F_j：单位 cycles/s（当前 `MecServer.freq=20e9` 保留）。
- 本地频率 f_UE：单位 cycles/s（当前 `MecAgent.freq=2.4e9` 保留）。
- 传输速率 R_ij：`R_ij = B * log2(1 + SNR_ij)`，单位 bit/s，B 为带宽（当前 `20e6` Hz）。

## 代码改动清单
- `onpolicy/envs/my/core.py`
  1) 任务初始化量级：将 `Task.input_data` 改为以 bit 表示，范围 `[16e6, 160e6]`（对应 2–20 MB）；将 `Task.exe_data` 改为 cycles，范围 `[5e8, 5e10]`；`Task.delay_tol` 改为按秒生成范围 `[0.1, 2.0]`，并继续转换为秒存入 `agent.state.task_delay_tol`。
  2) 传输速率：`compute_trans_rate()` 中改为 `world.bandwidth * log2(1 + SNR)`，用秒级 `trans_t = D_i / R_ij`。
  3) 边缘提交计算量：`MecServer.submit_offload_task()` 去掉 `alpha_comp`，直接 `computation_requirement = agent.state.task_e_s`（cycles）。
  4) 本地时延：`t_local = C_i / (v_alloc * f_UE)` 保持不变（单位秒）。
- `onpolicy/envs/my/task_queue.py`
  5) 资源处理公式：`cur_comp = time * total_computation_power * allocated_resource`（单位 cycles）；删除 `/(8 * 10e6)` 的经验常数，改为严格 cycles 模型。
  6) 超时判断仍按“时隙推进”，但外部 τ_i 用秒，失败最终时延用 `max_tolerance_delay_slots * slot_time` 统一为秒。
- 一致性与下游：
  7) `edge_cost`、`agent_utility`、奖励与总目标中时间项已按秒处理，无需改动逻辑，只随上游单位修正自动生效。

## 验证与影响
- 验证：随机若干任务，打印 `D_i`（Mb 转 bit）、`C_i`（cycles）、`R_ij`（bit/s）、`t_cur`（秒）；确认量级在预期范围。
- 影响：
  - 传输时延会随 `B` 与 SNR 合理缩放；计算时延与资源分配将严格按 cycles 线性推进；
  - 队列内的完成/失败触发与超时逻辑保持原样，外部度量统一为秒；
  - 可视化与奖励曲线不需额外调整（已统一到秒）。

## 备注
- 若论文有更具体的量级（例如图像分类 1e9 cycles、视频帧 10 MB、τ=200 ms），可在参数处细化区间；本计划采用广泛的车辆边缘计算任务的合理量级作为默认。