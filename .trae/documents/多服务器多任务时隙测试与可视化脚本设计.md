## 目标
- 设计一个可运行的测试脚本：多服务器、每个时隙为每台服务器随机产生多个任务，任务分布仿照 core 中的生成（input/exe/type），并确保容忍度不至于立即失败。
- 持续保存实时图片，直观展示每台服务器队列（高/中/低）、权重、近截止数、完成/失败累计。

## 方案概述
- 新建脚本 `onpolicy/envs/my/multi_server_demo.py`，独立于训练流程运行。
- 使用 `core.MecServer` 来承载每个服务器（内含 `PriorityQueueServer`）。不使用智能体卸载，直接为每台服务器在每个时隙注入多个任务。
- 使用已实现的 `visualize.QueueVisualizer` 每个时隙输出一张 PNG 到 `visual_out/slot_<t>.png`。

## 任务生成设计
- 分布参考 core 的 `Task`：
  - `input_data`: 均匀分布 `U(5000, 10000)`
  - `exe_data`: 均匀分布 `U(5000, 40000)`（作为 `ComputeTask.computation_requirement`）
  - `type`: `randint(0, 1)`（仅保留以便扩展）
- 容忍度：保证不“秒失败”，用秒级窗口：
  - `delay_tol`: 均匀分布 `U(1.0, 5.0)` 秒
  - 换算为时隙：`max_slots = ceil(delay_tol / server.priority_server.slot_time)`，当前 `slot_time=0.1s`，即 10–50 个时隙。
- 每时隙任务数：每台服务器 `N_tasks ~ randint(2, 5)`，为每个任务分配唯一 `task_id`（含服务器 id 和时隙计数）。

## 运行流程
- 初始化 S 台服务器（例如 S=3），设置位置（可选）与 `id`，保持频率 `freq=1.0e10`。
- 全局时隙循环 `t in [1..T]`：
  - 对每个服务器 s：
    - 生成 `N_tasks` 个任务，构造 `ComputeTask` 并 `add_task` 到 `s.priority_server`（`creation_slot=s.priority_server.current_slot`）。
    - 调用 `s.priority_server.process_time_slot()` 推进队列。
  - 调用 `QueueVisualizer.update(servers, t)` 输出 PNG。

## 脚本结构
- 入口 `if __name__ == "__main__"`：
  - 参数：服务器数 S、总时隙数 T、随机种子（可选）。
  - 生成任务并保存图片序列，最后打印统计（每台服务器完成/失败计数）。
- 保持优先级仅由紧急度分数判定（现有实现已满足）。

## 验证要点
- 任务不在第 1 个时隙立即失败；随时隙推进有完成/失败累计，符合期望。
- 图片展示：三队列数量、队列权重、近截止数量、完成/失败累计随时间变化。
- 可调：若完成率过低，增加容忍度上界或减小 `exe_data` 上界；若过高，反之。

## 交付与运行
- 新增 `multi_server_demo.py`，无需改动现有训练逻辑。
- 运行命令：`python on-policy-main/on-policy-main/onpolicy/envs/my/multi_server_demo.py`。
- 输出目录：`visual_out/slot_<t>.png`。