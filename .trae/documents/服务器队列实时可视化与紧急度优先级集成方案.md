## 目标
- 按架构要求：优先级仅依据“紧急度分数”判定，不引入资源需求因子。
- 为每个服务器提供“实时图片”展示：队列状态、高/中/低权重、近截止数量、任务完成/失败情况以及任务剩余计算量。

## 现状与改动点
- 现状：`PriorityQueueServer` 已支持多级队列、闭环权重分配与时隙推进；`MecServer` 已能将任务入队；`edge_cost` 已改为只计算传输并提交任务。
- 改动：
  1. 恢复 `TaskPriorityEvaluator.determine_priority` 为“仅紧急度评分”逻辑（去掉复合分数），保持高/中/低阈值。
  2. 保留服务器侧“跨队列动态权重分配”与闭环编排，确保实时性优先且避免饥饿。
  3. 新增实时可视化模块，输出 PNG 序列或动图，便于在 IDE 内查看。

## 可视化设计
- 新增 `onpolicy/envs/my/visualize.py`
  - `QueueVisualizer`：
    - 输入：服务器列表、当前时隙。
    - 采集：每台服务器的队列长度（高/中/低）、队列权重（w_H/w_M/w_L）、近截止数量、完成/失败累计、当前队列内各任务的`task_id/agent_id/remaining_computation/status`。
    - 输出：
      - 子图1（每台服务器一列条形图）：显示三类队列长度，图例含权重与近截止数量。
      - 子图2（任务状态表或条形图）：按任务状态着色（pending/processing/completed/failed），标注剩余计算量。
    - 渲染：`matplotlib`，每步生成 `visual_out/slot_<t>.png`；可选使用 `FuncAnimation`/`imageio` 合成GIF。
  - 可配置：渲染频率（例如每 N 步渲染一次以降低开销）。

## 集成与调用
- 在 `MecWorld.step` 执行服务器 `process_time_slot()` 后调用 `QueueVisualizer.update(servers, time_slot)`。
- 在演示入口（如 `demo_server_allocation` 或新建 `run_demo.py`）调用若干步，生成连续帧图片以观察动态变化。

## 验证方案
- 构造 1-2 台服务器、若干智能体，随机生成任务，运行 50-100 步：
  - 观察各队列高/中/低长度变化与权重变化是否合理。
  - 检查任务状态流转：pending→processing→completed/failed；图片中是否准确反映剩余计算量与完成/失败累计。
  - 对比“仅紧急度优先级 + 闭环权重分配”与“FIFO”的差异（可选）。

## 交付内容
- 恢复优先级评估为紧急度单因子。
- 新增 `visualize.py` 模块与`QueueVisualizer`，生成实时图片到 `visual_out/`。
- 在环境步进中集成可视化调用；提供一个演示入口脚本或函数。

## 依赖说明
- 使用 `matplotlib`（如环境缺失，将自动提示安装或降级为仅保存CSV统计）。